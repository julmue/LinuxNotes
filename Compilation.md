# Compilation of programs

This is relevant for apt-packaging-tool (APT).

## compilation

compiling and installing in essential steps (sufficient in many cases):

    0. Preperation:
	* downloading of the sourcefile into a directory
    	* resolve dependencies
    1. ./configure
    2. make
    3. sudo checkinstall

## Step 0.1: the sources
get and unpack the stuff...

### Step 0.2: resolve dependencies:
dependencies have to be resolved by hand for self compiled programs.
usually the output of 'configure' indicates missing dependencies.

("biggest missing link at start: build-essentials")

big help: apt-file find
example:
apt-file -l find libgtk | grep dev

### Case 1: dependencies for a newer version of a package thats in the repos
Situation: older package is in the package-repositories with its dependencies.
but it has not been installed yet.
newer version of the package shall be installed from source.
One-liner in the terminal: `sudo apt-get build-dep <PACKAGENAME>`
installs relevant dependencies as far as they are known.

### Case 2: resolving dependencies for a brand new program
it's possible to make a distinction between 5 different forms of dependencies:

* tool chain dependencies
* Development files of libraries for compiling: prefix lib, suffix -dev
* Development files of programs for compiling: suffix -dev
* programs that are base of the compiled program (Xserver, ...)
* Libraries that are base of the compile program (...???)

#### worst case: already installed version of a dependency differs from a needed dependency

newer versions are seldom a problem
older versions are trouble

TODO: SONAME
Debian packages naming scheme: "lib|LIBRARYNAME|MAJOR-VERSION_MINOR-VERSION"
all major versions are kompatible.


## Step 1: Configuration
invoke the configuration script: `./configure`

Checks if the library is compatible to the environment and if all dependecies are resolved.
(and compiler options and so on).
The configure script is not always there.
`configure`-scripts are usually generated by the `autotools` build-system.

If there is no `configure` script but an `autogen.sh` the configuration script
is generated by invocing that file.

sometimes specific flags cna be send to the compiler as an option for the configure script:
example: `/configure --prefix=/usr/local`.
Self-compiled programs should be installed into `usr/local` ALWAYS.
other paths can be specified via the `prefix` flag

other options can be seen via `/configure --help`

## Step 2: Compilations 
compiling starts with the command `make`.

## Step 3: Installation
installation with `checkinstall`.

The program prompts for some package metainformations ...
correctly edit the package name and the version number !!!!
A wrong version number can lead to the situation, that 
the old package gets recommended by ubuntu ... look at versioning in ubuntu/debian.

To stop automatic installation of the fresh package:
`checkinstall --install=no`
or use checkinstall without root permissons.

Don't compile kernel modules with checkinstall ...

## The DEBIAN METHOD: dh-make and fakeroot
### 1: configure:
Running configure is optional (gets executed by fakeroot by default) only with special options
### 2: dh_make
`dh_make` generates debian package info
for the package type: 'single binary'

`dh_make --createorig` 

`dh_make` generates the rules `fakeroot`
### 3: compiling

fakeroot debian/rules binary 

The configure script gets executed automatically,
the program gets compiled
and a debian `*.deb` package gets created above the source folder.
Contrary to checkinstall this package does _not_ get installed automtically
(no sudo is needed).
The package can be installed as usual.

## Local install:
`./configure --prefix=$HOME`
`make` 
`make install`
`make home-desktop-install`

## Cleaning of the source directory:

for example to undo wrong arguments to configure script ...
    
    make clean

### cmake (also call with checkinstall of DEBIAN method)

TODO

## patch and diff

situation 1:   
you try to compile a package from source
you learn that somebody already has made the relevant additions for your system ... in a _patch_
-> use the program `patch`

situation 2:  
you wrote a patch for sourcecode yourself and want to distribute is to other people
-> use the program `diff`

## apply patches with "patch"
apply patch to a single file (and patch is in unified format):

    patch < foo.patch

Otherwise a name can be given:

    patch foo.txt < bar.patch

Applying patches to a whole directory, similar but attention with p-level.

    patch -p1 < baz.patc

    patch -Np1 -d dmenu-4.5  < dmenu-4.5-xft-debian.diffh

q: inspect patch?
text files just use `less` or something.


