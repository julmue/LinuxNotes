# Notes On Linux

## file system

### What is a file system?

File systems are used to organize a partition, that reading and writing
data to the storage medium can happen in a structured and organized way.

Different file systems serve different purposes.

### basic vocabulary

partition
formatting

### partitioning a medium

_Partitioning_ means to fragment a storage medium in one or more
distinct and independent sections - the partitions.
With partitions it is possible to:
    * better structuring of data.
    * usage of multiple different file systems (...)

Before any data can be stored a file system has
to be established in a partition. 
The installation of a file system is called formatting.

A partition can stay unformatted. 

### Formatting a medium
Before formatting a medium it has to be partitioned.

## Compilation of programs

This is relevant for apt-packaging-tool (APT).

### compilation

compiling and installing in essential steps (sufficient in many cases):

    0. Preperation:
	* downloading of the sourcefile into a directory
    	* resolve dependencies
    1. ./configure
    2. make
    3. sudo checkinstall

### step 0.1: the sources
get and unpack the stuff...

### step 0.2: resolve dependencies:
dependencies have to be resolved by hand for self compiled programs.
usually the output of 'configure' indicates missing dependencies.

("biggest missing link at start: build-essentials")

big help: apt-file find
example:
apt-file -l find libgtk | grep dev

#### case 1: dependencies for a newer version of a package thats in the repos
Situation: older package is in the package-repositories with its dependencies.
but it has not been installed yet.
newer version of the package shall be installed from source.
One-liner in the terminal: `sudo apt-get build-dep <PACKAGENAME>`
installs relevant dependencies as far as they are known.

#### case 2: resolving dependencies for a brand new program
it's possible to make a distinction between 5 different forms of dependencies:

    * tool chain dependencies
    * Development files of libraries for compiling: prefix lib, suffix -dev
    * Development files of programs for compiling: suffix -dev
    * programs that are base of the compiled program (Xserver, ...)
    * Libraries that are base of the compile program (...???)

##### worst case: already installed version of a dependency differs from a needed dependency

newer versions are seldom a problem
older versions are trouble

TODO: SONAME
Debian packages naming scheme: "lib|LIBRARYNAME|MAJOR-VERSION_MINOR-VERSION"
all major versions are kompatible.


### step 1: Configuration
invoke the configuration script: `./configure`

Checks if the library is compatible to the environment and if all dependecies are resolved.
(and compiler options and so on).
The configure script is not always there.
`configure`-scripts are usually generated by the `autotools` build-system.

If there is no `configure` script but an `autogen.sh` the configuration script
is generated by invocing that file.

sometimes specific flags cna be send to the compiler as an option for the configure script:
example: `/configure --prefix=/usr/local`.
Self-compiled programs should be installed into `usr/local` ALWAYS.
other paths can be specified via the `prefix` flag

other options can be seen via `/configure --help`

### step 2: Compilations 
compiling starts with the command `make`.

### step 3: Installation
installation with `checkinstall`.

The program prompts for some package metainformations ...
correctly edit the package name and the version number !!!!
A wrong version number can lead to the situation, that 
the old package gets recommended by ubuntu ... look at versioning in ubuntu/debian.

To stop automatic installation of the fresh package:
`checkinstall --install=no`
or use checkinstall without root permissons.

Don't compile kernel modules with checkinstall ...

### The DEBIAN METHOD: dh-make and fakeroot
#### 1: configure:
Running configure is optional (gets executed by fakeroot by default) only with special options
#### 2: dh_make
`dh_make` generates debian package info
for the package type: 'single binary'

`dh_make --createorig` 

`dh_make` generates the rules `fakeroot`
#### 3: compiling

fakeroot debian/rules binary 

The configure script gets executed automatically,
the program gets compiled
and a debian `*.deb` package gets created above the source folder.
Contrary to checkinstall this package does _not_ get installed automtically
(no sudo is needed).
The package can be installed as usual.

### Local install:
`./configure --prefix=$HOME`
`make` 
`make install`
`make home-desktop-install`

### Other methods:

### Cleaning of the source directory:

for example to undo wrong arguments to configure script ...
make clean

#### cmake (also call with checkinstall of DEBIAN method)

TODO

## patch and diff

situation 1:   
you try to compile a package from source
you learn that somebody already has made the relevant additions for your system ... in a _patch_
-> use the program `patch`

situation 2:  
you wrote a patch for sourcecode yourself and want to distribute is to other people
-> use the program `diff`

### apply patches with "patch"
apply patch to a single file (and patch is in unified format):

    patch < foo.patch

Otherwise a name can be given:

    patch foo.txt < bar.patch

Applying patches to a whole directory, similar but attention with p-level.

    patch -p1 < baz.patc

    patch -Np1 -d dmenu-4.5  < dmenu-4.5-xft-debian.diffh

q: inspect patch?
text files just use `less` or something.


## XServer

What is the X-server?

### Xinerama

Xinerama is an extension to X window System that enables X application
and window managers to use two or more phyiscal displays as one large
display

### On how many billion, trillion places do I configure X-server?

Only for global changes that affect all users
`/etc/X11/xorg` conf gets read only at the start of the x-server.
the files in the folders `/usr/lib/X11/xorg.con.d/`
and/or `/usr/share/X11/xorg.cond.d/` get read during every plugin of a new device
there are some differences to `etc/X11/xorg.conf`.

By default debian based systems have no `/etc/X11/xorg.conf`.

to creage one:
1. go to console
2. stop window manager (sudo service mdm stop,..)
3. `Xorg -configure`
   this will create `xorg.conf.new` in Home (with some insignificant error messages)
4. restart window manager (`sudo service mdm start`)
5. open home folder and edit
6. `sudo cp xorg.conf /etc/X11`

#### /etc/X11/xorg.conf

    man xorg.conf

to use multi-head:
USE THE XRANDR SYNTAX FOR GOOOOOOOODS SAKE!!!!!!!!!!!
PLEASE,SO SIMPLE ... XRANDR XORG.CONF!!!

## Misc
### Downloading a complete website

use wget:
example: `wget -r --no-parent`

## Recovery mode
for totally fucked up systems there is a recovery mode:
hold shift during boot.

## Questions

### Kernel ... 
how to compile your own kernel?

### atp

wie werden paketquellen untersucht?

    apt-file
    apt-search

What criteria can be used for searching for a package?
Where are the packages stored?
How does the whole thing work?

### How to manage self compiled sources in debian?
first hint: the program checkinstall 

### How to keep track of changes made to different config files?
use version control `git`
critical: file permissions have to be kept

### How to globally remap the keyboad layout?
I want to swap CAPS for ESC in every subsystem not only the window manager
how can this be achieved?
Is there some kind of hardware device?

### How to globally install files using cabal?
do that with xmonad!!!!!
